// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MocapExchange.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_MocapExchange_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_MocapExchange_2eproto

#include <limits>
#include <string>
THIRD_PARTY_INCLUDES_START
#include <google/protobuf/port_def.inc>
THIRD_PARTY_INCLUDES_END
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif
THIRD_PARTY_INCLUDES_START
#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
THIRD_PARTY_INCLUDES_END
#define PROTOBUF_INTERNAL_EXPORT_MocapExchange_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_MocapExchange_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_MocapExchange_2eproto;
namespace Mocap {
class Environment;
struct EnvironmentDefaultTypeInternal;
extern EnvironmentDefaultTypeInternal _Environment_default_instance_;
class EnvironmentRequest;
struct EnvironmentRequestDefaultTypeInternal;
extern EnvironmentRequestDefaultTypeInternal _EnvironmentRequest_default_instance_;
class Joint;
struct JointDefaultTypeInternal;
extern JointDefaultTypeInternal _Joint_default_instance_;
class JointMeta;
struct JointMetaDefaultTypeInternal;
extern JointMetaDefaultTypeInternal _JointMeta_default_instance_;
class Link;
struct LinkDefaultTypeInternal;
extern LinkDefaultTypeInternal _Link_default_instance_;
class MocapStreamRequest;
struct MocapStreamRequestDefaultTypeInternal;
extern MocapStreamRequestDefaultTypeInternal _MocapStreamRequest_default_instance_;
class MocapStreamResponse;
struct MocapStreamResponseDefaultTypeInternal;
extern MocapStreamResponseDefaultTypeInternal _MocapStreamResponse_default_instance_;
class Orientation;
struct OrientationDefaultTypeInternal;
extern OrientationDefaultTypeInternal _Orientation_default_instance_;
class Pose;
struct PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class Structure;
struct StructureDefaultTypeInternal;
extern StructureDefaultTypeInternal _Structure_default_instance_;
class StructureRequest;
struct StructureRequestDefaultTypeInternal;
extern StructureRequestDefaultTypeInternal _StructureRequest_default_instance_;
class StructureResponse;
struct StructureResponseDefaultTypeInternal;
extern StructureResponseDefaultTypeInternal _StructureResponse_default_instance_;
class Transform;
struct TransformDefaultTypeInternal;
extern TransformDefaultTypeInternal _Transform_default_instance_;
class Translation;
struct TranslationDefaultTypeInternal;
extern TranslationDefaultTypeInternal _Translation_default_instance_;
}  // namespace Mocap
PROTOBUF_NAMESPACE_OPEN
template<> ::Mocap::Environment* Arena::CreateMaybeMessage<::Mocap::Environment>(Arena*);
template<> ::Mocap::EnvironmentRequest* Arena::CreateMaybeMessage<::Mocap::EnvironmentRequest>(Arena*);
template<> ::Mocap::Joint* Arena::CreateMaybeMessage<::Mocap::Joint>(Arena*);
template<> ::Mocap::JointMeta* Arena::CreateMaybeMessage<::Mocap::JointMeta>(Arena*);
template<> ::Mocap::Link* Arena::CreateMaybeMessage<::Mocap::Link>(Arena*);
template<> ::Mocap::MocapStreamRequest* Arena::CreateMaybeMessage<::Mocap::MocapStreamRequest>(Arena*);
template<> ::Mocap::MocapStreamResponse* Arena::CreateMaybeMessage<::Mocap::MocapStreamResponse>(Arena*);
template<> ::Mocap::Orientation* Arena::CreateMaybeMessage<::Mocap::Orientation>(Arena*);
template<> ::Mocap::Pose* Arena::CreateMaybeMessage<::Mocap::Pose>(Arena*);
template<> ::Mocap::Structure* Arena::CreateMaybeMessage<::Mocap::Structure>(Arena*);
template<> ::Mocap::StructureRequest* Arena::CreateMaybeMessage<::Mocap::StructureRequest>(Arena*);
template<> ::Mocap::StructureResponse* Arena::CreateMaybeMessage<::Mocap::StructureResponse>(Arena*);
template<> ::Mocap::Transform* Arena::CreateMaybeMessage<::Mocap::Transform>(Arena*);
template<> ::Mocap::Translation* Arena::CreateMaybeMessage<::Mocap::Translation>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Mocap {

enum Environment_DirectionType : int {
  Environment_DirectionType_LEFT_HAND = 0,
  Environment_DirectionType_RIGHT_HAND = 1,
  Environment_DirectionType_Environment_DirectionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Environment_DirectionType_Environment_DirectionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Environment_DirectionType_IsValid(int value);
constexpr Environment_DirectionType Environment_DirectionType_DirectionType_MIN = Environment_DirectionType_LEFT_HAND;
constexpr Environment_DirectionType Environment_DirectionType_DirectionType_MAX = Environment_DirectionType_RIGHT_HAND;
constexpr int Environment_DirectionType_DirectionType_ARRAYSIZE = Environment_DirectionType_DirectionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Environment_DirectionType_descriptor();
template<typename T>
inline const std::string& Environment_DirectionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Environment_DirectionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Environment_DirectionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Environment_DirectionType_descriptor(), enum_t_value);
}
inline bool Environment_DirectionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Environment_DirectionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Environment_DirectionType>(
    Environment_DirectionType_descriptor(), name, value);
}
enum Environment_DistanceUnits : int {
  Environment_DistanceUnits_MM = 0,
  Environment_DistanceUnits_CM = 1,
  Environment_DistanceUnits_M = 2,
  Environment_DistanceUnits_Environment_DistanceUnits_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Environment_DistanceUnits_Environment_DistanceUnits_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Environment_DistanceUnits_IsValid(int value);
constexpr Environment_DistanceUnits Environment_DistanceUnits_DistanceUnits_MIN = Environment_DistanceUnits_MM;
constexpr Environment_DistanceUnits Environment_DistanceUnits_DistanceUnits_MAX = Environment_DistanceUnits_M;
constexpr int Environment_DistanceUnits_DistanceUnits_ARRAYSIZE = Environment_DistanceUnits_DistanceUnits_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Environment_DistanceUnits_descriptor();
template<typename T>
inline const std::string& Environment_DistanceUnits_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Environment_DistanceUnits>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Environment_DistanceUnits_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Environment_DistanceUnits_descriptor(), enum_t_value);
}
inline bool Environment_DistanceUnits_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Environment_DistanceUnits* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Environment_DistanceUnits>(
    Environment_DistanceUnits_descriptor(), name, value);
}
enum Environment_TimeUnits : int {
  Environment_TimeUnits_SEC = 0,
  Environment_TimeUnits_MILS = 1,
  Environment_TimeUnits_NSEC = 2,
  Environment_TimeUnits_Environment_TimeUnits_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Environment_TimeUnits_Environment_TimeUnits_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Environment_TimeUnits_IsValid(int value);
constexpr Environment_TimeUnits Environment_TimeUnits_TimeUnits_MIN = Environment_TimeUnits_SEC;
constexpr Environment_TimeUnits Environment_TimeUnits_TimeUnits_MAX = Environment_TimeUnits_NSEC;
constexpr int Environment_TimeUnits_TimeUnits_ARRAYSIZE = Environment_TimeUnits_TimeUnits_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Environment_TimeUnits_descriptor();
template<typename T>
inline const std::string& Environment_TimeUnits_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Environment_TimeUnits>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Environment_TimeUnits_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Environment_TimeUnits_descriptor(), enum_t_value);
}
inline bool Environment_TimeUnits_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Environment_TimeUnits* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Environment_TimeUnits>(
    Environment_TimeUnits_descriptor(), name, value);
}
enum Orientation_RotationType : int {
  Orientation_RotationType_QUATERNION = 0,
  Orientation_RotationType_MATRIX = 1,
  Orientation_RotationType_EULER_XYZ = 2,
  Orientation_RotationType_EULER_XZY = 3,
  Orientation_RotationType_EULER_YXZ = 4,
  Orientation_RotationType_EULER_YZX = 5,
  Orientation_RotationType_EULER_ZXY = 6,
  Orientation_RotationType_EULER_ZYX = 7,
  Orientation_RotationType_Orientation_RotationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Orientation_RotationType_Orientation_RotationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Orientation_RotationType_IsValid(int value);
constexpr Orientation_RotationType Orientation_RotationType_RotationType_MIN = Orientation_RotationType_QUATERNION;
constexpr Orientation_RotationType Orientation_RotationType_RotationType_MAX = Orientation_RotationType_EULER_ZYX;
constexpr int Orientation_RotationType_RotationType_ARRAYSIZE = Orientation_RotationType_RotationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Orientation_RotationType_descriptor();
template<typename T>
inline const std::string& Orientation_RotationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Orientation_RotationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Orientation_RotationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Orientation_RotationType_descriptor(), enum_t_value);
}
inline bool Orientation_RotationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Orientation_RotationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Orientation_RotationType>(
    Orientation_RotationType_descriptor(), name, value);
}
enum StructureType : int {
  HUMAN = 0,
  BALL = 1,
  BIKE = 2,
  StructureType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StructureType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StructureType_IsValid(int value);
constexpr StructureType StructureType_MIN = HUMAN;
constexpr StructureType StructureType_MAX = BIKE;
constexpr int StructureType_ARRAYSIZE = StructureType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StructureType_descriptor();
template<typename T>
inline const std::string& StructureType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StructureType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StructureType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StructureType_descriptor(), enum_t_value);
}
inline bool StructureType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StructureType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StructureType>(
    StructureType_descriptor(), name, value);
}
// ===================================================================

class Environment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Mocap.Environment) */ {
 public:
  inline Environment() : Environment(nullptr) {}
  ~Environment() override;
  explicit constexpr Environment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Environment(const Environment& from);
  Environment(Environment&& from) noexcept
    : Environment() {
    *this = ::std::move(from);
  }

  inline Environment& operator=(const Environment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Environment& operator=(Environment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Environment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Environment* internal_default_instance() {
    return reinterpret_cast<const Environment*>(
               &_Environment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Environment& a, Environment& b) {
    a.Swap(&b);
  }
  inline void Swap(Environment* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Environment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Environment* New() const final {
    return new Environment();
  }

  Environment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Environment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Environment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Environment& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Environment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mocap.Environment";
  }
  protected:
  explicit Environment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Environment_DirectionType DirectionType;
  static constexpr DirectionType LEFT_HAND =
    Environment_DirectionType_LEFT_HAND;
  static constexpr DirectionType RIGHT_HAND =
    Environment_DirectionType_RIGHT_HAND;
  static inline bool DirectionType_IsValid(int value) {
    return Environment_DirectionType_IsValid(value);
  }
  static constexpr DirectionType DirectionType_MIN =
    Environment_DirectionType_DirectionType_MIN;
  static constexpr DirectionType DirectionType_MAX =
    Environment_DirectionType_DirectionType_MAX;
  static constexpr int DirectionType_ARRAYSIZE =
    Environment_DirectionType_DirectionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DirectionType_descriptor() {
    return Environment_DirectionType_descriptor();
  }
  template<typename T>
  static inline const std::string& DirectionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DirectionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DirectionType_Name.");
    return Environment_DirectionType_Name(enum_t_value);
  }
  static inline bool DirectionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DirectionType* value) {
    return Environment_DirectionType_Parse(name, value);
  }

  typedef Environment_DistanceUnits DistanceUnits;
  static constexpr DistanceUnits MM =
    Environment_DistanceUnits_MM;
  static constexpr DistanceUnits CM =
    Environment_DistanceUnits_CM;
  static constexpr DistanceUnits M =
    Environment_DistanceUnits_M;
  static inline bool DistanceUnits_IsValid(int value) {
    return Environment_DistanceUnits_IsValid(value);
  }
  static constexpr DistanceUnits DistanceUnits_MIN =
    Environment_DistanceUnits_DistanceUnits_MIN;
  static constexpr DistanceUnits DistanceUnits_MAX =
    Environment_DistanceUnits_DistanceUnits_MAX;
  static constexpr int DistanceUnits_ARRAYSIZE =
    Environment_DistanceUnits_DistanceUnits_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DistanceUnits_descriptor() {
    return Environment_DistanceUnits_descriptor();
  }
  template<typename T>
  static inline const std::string& DistanceUnits_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DistanceUnits>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DistanceUnits_Name.");
    return Environment_DistanceUnits_Name(enum_t_value);
  }
  static inline bool DistanceUnits_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DistanceUnits* value) {
    return Environment_DistanceUnits_Parse(name, value);
  }

  typedef Environment_TimeUnits TimeUnits;
  static constexpr TimeUnits SEC =
    Environment_TimeUnits_SEC;
  static constexpr TimeUnits MILS =
    Environment_TimeUnits_MILS;
  static constexpr TimeUnits NSEC =
    Environment_TimeUnits_NSEC;
  static inline bool TimeUnits_IsValid(int value) {
    return Environment_TimeUnits_IsValid(value);
  }
  static constexpr TimeUnits TimeUnits_MIN =
    Environment_TimeUnits_TimeUnits_MIN;
  static constexpr TimeUnits TimeUnits_MAX =
    Environment_TimeUnits_TimeUnits_MAX;
  static constexpr int TimeUnits_ARRAYSIZE =
    Environment_TimeUnits_TimeUnits_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TimeUnits_descriptor() {
    return Environment_TimeUnits_descriptor();
  }
  template<typename T>
  static inline const std::string& TimeUnits_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TimeUnits>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TimeUnits_Name.");
    return Environment_TimeUnits_Name(enum_t_value);
  }
  static inline bool TimeUnits_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TimeUnits* value) {
    return Environment_TimeUnits_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGravityFieldNumber = 1,
    kDistUnitsFieldNumber = 2,
    kTimeUnitsFieldNumber = 3,
    kDirectionTypeFieldNumber = 4,
  };
  // float gravity = 1;
  void clear_gravity();
  float gravity() const;
  void set_gravity(float value);
  private:
  float _internal_gravity() const;
  void _internal_set_gravity(float value);
  public:

  // .Mocap.Environment.DistanceUnits distUnits = 2;
  void clear_distunits();
  ::Mocap::Environment_DistanceUnits distunits() const;
  void set_distunits(::Mocap::Environment_DistanceUnits value);
  private:
  ::Mocap::Environment_DistanceUnits _internal_distunits() const;
  void _internal_set_distunits(::Mocap::Environment_DistanceUnits value);
  public:

  // .Mocap.Environment.TimeUnits timeUnits = 3;
  void clear_timeunits();
  ::Mocap::Environment_TimeUnits timeunits() const;
  void set_timeunits(::Mocap::Environment_TimeUnits value);
  private:
  ::Mocap::Environment_TimeUnits _internal_timeunits() const;
  void _internal_set_timeunits(::Mocap::Environment_TimeUnits value);
  public:

  // .Mocap.Environment.DirectionType directionType = 4;
  void clear_directiontype();
  ::Mocap::Environment_DirectionType directiontype() const;
  void set_directiontype(::Mocap::Environment_DirectionType value);
  private:
  ::Mocap::Environment_DirectionType _internal_directiontype() const;
  void _internal_set_directiontype(::Mocap::Environment_DirectionType value);
  public:

  // @@protoc_insertion_point(class_scope:Mocap.Environment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float gravity_;
  int distunits_;
  int timeunits_;
  int directiontype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MocapExchange_2eproto;
};
// -------------------------------------------------------------------

class Translation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Mocap.Translation) */ {
 public:
  inline Translation() : Translation(nullptr) {}
  ~Translation() override;
  explicit constexpr Translation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Translation(const Translation& from);
  Translation(Translation&& from) noexcept
    : Translation() {
    *this = ::std::move(from);
  }

  inline Translation& operator=(const Translation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Translation& operator=(Translation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Translation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Translation* internal_default_instance() {
    return reinterpret_cast<const Translation*>(
               &_Translation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Translation& a, Translation& b) {
    a.Swap(&b);
  }
  inline void Swap(Translation* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Translation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Translation* New() const final {
    return new Translation();
  }

  Translation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Translation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Translation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Translation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Translation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mocap.Translation";
  }
  protected:
  explicit Translation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:Mocap.Translation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MocapExchange_2eproto;
};
// -------------------------------------------------------------------

class Orientation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Mocap.Orientation) */ {
 public:
  inline Orientation() : Orientation(nullptr) {}
  ~Orientation() override;
  explicit constexpr Orientation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Orientation(const Orientation& from);
  Orientation(Orientation&& from) noexcept
    : Orientation() {
    *this = ::std::move(from);
  }

  inline Orientation& operator=(const Orientation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orientation& operator=(Orientation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Orientation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Orientation* internal_default_instance() {
    return reinterpret_cast<const Orientation*>(
               &_Orientation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Orientation& a, Orientation& b) {
    a.Swap(&b);
  }
  inline void Swap(Orientation* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Orientation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Orientation* New() const final {
    return new Orientation();
  }

  Orientation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Orientation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Orientation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Orientation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Orientation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mocap.Orientation";
  }
  protected:
  explicit Orientation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Orientation_RotationType RotationType;
  static constexpr RotationType QUATERNION =
    Orientation_RotationType_QUATERNION;
  static constexpr RotationType MATRIX =
    Orientation_RotationType_MATRIX;
  static constexpr RotationType EULER_XYZ =
    Orientation_RotationType_EULER_XYZ;
  static constexpr RotationType EULER_XZY =
    Orientation_RotationType_EULER_XZY;
  static constexpr RotationType EULER_YXZ =
    Orientation_RotationType_EULER_YXZ;
  static constexpr RotationType EULER_YZX =
    Orientation_RotationType_EULER_YZX;
  static constexpr RotationType EULER_ZXY =
    Orientation_RotationType_EULER_ZXY;
  static constexpr RotationType EULER_ZYX =
    Orientation_RotationType_EULER_ZYX;
  static inline bool RotationType_IsValid(int value) {
    return Orientation_RotationType_IsValid(value);
  }
  static constexpr RotationType RotationType_MIN =
    Orientation_RotationType_RotationType_MIN;
  static constexpr RotationType RotationType_MAX =
    Orientation_RotationType_RotationType_MAX;
  static constexpr int RotationType_ARRAYSIZE =
    Orientation_RotationType_RotationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RotationType_descriptor() {
    return Orientation_RotationType_descriptor();
  }
  template<typename T>
  static inline const std::string& RotationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RotationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RotationType_Name.");
    return Orientation_RotationType_Name(enum_t_value);
  }
  static inline bool RotationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RotationType* value) {
    return Orientation_RotationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated float values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  float _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_values() const;
  void _internal_add_values(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_values();
  public:
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_values();

  // .Mocap.Orientation.RotationType type = 1;
  void clear_type();
  ::Mocap::Orientation_RotationType type() const;
  void set_type(::Mocap::Orientation_RotationType value);
  private:
  ::Mocap::Orientation_RotationType _internal_type() const;
  void _internal_set_type(::Mocap::Orientation_RotationType value);
  public:

  // @@protoc_insertion_point(class_scope:Mocap.Orientation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > values_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MocapExchange_2eproto;
};
// -------------------------------------------------------------------

class Transform final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Mocap.Transform) */ {
 public:
  inline Transform() : Transform(nullptr) {}
  ~Transform() override;
  explicit constexpr Transform(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transform(const Transform& from);
  Transform(Transform&& from) noexcept
    : Transform() {
    *this = ::std::move(from);
  }

  inline Transform& operator=(const Transform& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transform& operator=(Transform&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transform& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transform* internal_default_instance() {
    return reinterpret_cast<const Transform*>(
               &_Transform_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Transform& a, Transform& b) {
    a.Swap(&b);
  }
  inline void Swap(Transform* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transform* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Transform* New() const final {
    return new Transform();
  }

  Transform* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Transform>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Transform& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Transform& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transform* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mocap.Transform";
  }
  protected:
  explicit Transform(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTranslationFieldNumber = 1,
    kOrientationFieldNumber = 2,
  };
  // .Mocap.Translation translation = 1;
  bool has_translation() const;
  private:
  bool _internal_has_translation() const;
  public:
  void clear_translation();
  const ::Mocap::Translation& translation() const;
  PROTOBUF_MUST_USE_RESULT ::Mocap::Translation* release_translation();
  ::Mocap::Translation* mutable_translation();
  void set_allocated_translation(::Mocap::Translation* translation);
  private:
  const ::Mocap::Translation& _internal_translation() const;
  ::Mocap::Translation* _internal_mutable_translation();
  public:
  void unsafe_arena_set_allocated_translation(
      ::Mocap::Translation* translation);
  ::Mocap::Translation* unsafe_arena_release_translation();

  // .Mocap.Orientation orientation = 2;
  bool has_orientation() const;
  private:
  bool _internal_has_orientation() const;
  public:
  void clear_orientation();
  const ::Mocap::Orientation& orientation() const;
  PROTOBUF_MUST_USE_RESULT ::Mocap::Orientation* release_orientation();
  ::Mocap::Orientation* mutable_orientation();
  void set_allocated_orientation(::Mocap::Orientation* orientation);
  private:
  const ::Mocap::Orientation& _internal_orientation() const;
  ::Mocap::Orientation* _internal_mutable_orientation();
  public:
  void unsafe_arena_set_allocated_orientation(
      ::Mocap::Orientation* orientation);
  ::Mocap::Orientation* unsafe_arena_release_orientation();

  // @@protoc_insertion_point(class_scope:Mocap.Transform)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Mocap::Translation* translation_;
  ::Mocap::Orientation* orientation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MocapExchange_2eproto;
};
// -------------------------------------------------------------------

class Link final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Mocap.Link) */ {
 public:
  inline Link() : Link(nullptr) {}
  ~Link() override;
  explicit constexpr Link(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Link(const Link& from);
  Link(Link&& from) noexcept
    : Link() {
    *this = ::std::move(from);
  }

  inline Link& operator=(const Link& from) {
    CopyFrom(from);
    return *this;
  }
  inline Link& operator=(Link&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Link& default_instance() {
    return *internal_default_instance();
  }
  static inline const Link* internal_default_instance() {
    return reinterpret_cast<const Link*>(
               &_Link_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Link& a, Link& b) {
    a.Swap(&b);
  }
  inline void Swap(Link* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Link* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Link* New() const final {
    return new Link();
  }

  Link* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Link>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Link& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Link& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Link* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mocap.Link";
  }
  protected:
  explicit Link(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 6,
    kInertialMatrixFieldNumber = 7,
    kNameFieldNumber = 1,
    kOffsetFieldNumber = 4,
    kLinkIdFieldNumber = 2,
    kParentLinkIdFieldNumber = 3,
    kMassFieldNumber = 5,
  };
  // repeated float size = 6;
  int size_size() const;
  private:
  int _internal_size_size() const;
  public:
  void clear_size();
  private:
  float _internal_size(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_size() const;
  void _internal_add_size(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_size();
  public:
  float size(int index) const;
  void set_size(int index, float value);
  void add_size(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      size() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_size();

  // repeated float inertialMatrix = 7;
  int inertialmatrix_size() const;
  private:
  int _internal_inertialmatrix_size() const;
  public:
  void clear_inertialmatrix();
  private:
  float _internal_inertialmatrix(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_inertialmatrix() const;
  void _internal_add_inertialmatrix(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_inertialmatrix();
  public:
  float inertialmatrix(int index) const;
  void set_inertialmatrix(int index, float value);
  void add_inertialmatrix(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      inertialmatrix() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_inertialmatrix();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Mocap.Transform offset = 4;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  const ::Mocap::Transform& offset() const;
  PROTOBUF_MUST_USE_RESULT ::Mocap::Transform* release_offset();
  ::Mocap::Transform* mutable_offset();
  void set_allocated_offset(::Mocap::Transform* offset);
  private:
  const ::Mocap::Transform& _internal_offset() const;
  ::Mocap::Transform* _internal_mutable_offset();
  public:
  void unsafe_arena_set_allocated_offset(
      ::Mocap::Transform* offset);
  ::Mocap::Transform* unsafe_arena_release_offset();

  // uint32 linkId = 2;
  void clear_linkid();
  ::PROTOBUF_NAMESPACE_ID::uint32 linkid() const;
  void set_linkid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_linkid() const;
  void _internal_set_linkid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 parentLinkId = 3;
  void clear_parentlinkid();
  ::PROTOBUF_NAMESPACE_ID::uint32 parentlinkid() const;
  void set_parentlinkid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_parentlinkid() const;
  void _internal_set_parentlinkid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // float mass = 5;
  void clear_mass();
  float mass() const;
  void set_mass(float value);
  private:
  float _internal_mass() const;
  void _internal_set_mass(float value);
  public:

  // @@protoc_insertion_point(class_scope:Mocap.Link)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > inertialmatrix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::Mocap::Transform* offset_;
  ::PROTOBUF_NAMESPACE_ID::uint32 linkid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 parentlinkid_;
  float mass_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MocapExchange_2eproto;
};
// -------------------------------------------------------------------

class JointMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Mocap.JointMeta) */ {
 public:
  inline JointMeta() : JointMeta(nullptr) {}
  ~JointMeta() override;
  explicit constexpr JointMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JointMeta(const JointMeta& from);
  JointMeta(JointMeta&& from) noexcept
    : JointMeta() {
    *this = ::std::move(from);
  }

  inline JointMeta& operator=(const JointMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline JointMeta& operator=(JointMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JointMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const JointMeta* internal_default_instance() {
    return reinterpret_cast<const JointMeta*>(
               &_JointMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(JointMeta& a, JointMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(JointMeta* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JointMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JointMeta* New() const final {
    return new JointMeta();
  }

  JointMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JointMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JointMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JointMeta& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointMeta* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mocap.JointMeta";
  }
  protected:
  explicit JointMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kJointIdFieldNumber = 1,
    kLinkIdFieldNumber = 2,
  };
  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 jointId = 1;
  void clear_jointid();
  ::PROTOBUF_NAMESPACE_ID::uint32 jointid() const;
  void set_jointid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_jointid() const;
  void _internal_set_jointid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 linkId = 2;
  void clear_linkid();
  ::PROTOBUF_NAMESPACE_ID::uint32 linkid() const;
  void set_linkid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_linkid() const;
  void _internal_set_linkid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Mocap.JointMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 jointid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 linkid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MocapExchange_2eproto;
};
// -------------------------------------------------------------------

class Structure final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Mocap.Structure) */ {
 public:
  inline Structure() : Structure(nullptr) {}
  ~Structure() override;
  explicit constexpr Structure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Structure(const Structure& from);
  Structure(Structure&& from) noexcept
    : Structure() {
    *this = ::std::move(from);
  }

  inline Structure& operator=(const Structure& from) {
    CopyFrom(from);
    return *this;
  }
  inline Structure& operator=(Structure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Structure& default_instance() {
    return *internal_default_instance();
  }
  static inline const Structure* internal_default_instance() {
    return reinterpret_cast<const Structure*>(
               &_Structure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Structure& a, Structure& b) {
    a.Swap(&b);
  }
  inline void Swap(Structure* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Structure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Structure* New() const final {
    return new Structure();
  }

  Structure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Structure>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Structure& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Structure& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Structure* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mocap.Structure";
  }
  protected:
  explicit Structure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinksFieldNumber = 4,
    kJointsFieldNumber = 5,
    kNameFieldNumber = 3,
    kStructureIdFieldNumber = 1,
    kStructureTypeFieldNumber = 2,
  };
  // repeated .Mocap.Link links = 4;
  int links_size() const;
  private:
  int _internal_links_size() const;
  public:
  void clear_links();
  ::Mocap::Link* mutable_links(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Link >*
      mutable_links();
  private:
  const ::Mocap::Link& _internal_links(int index) const;
  ::Mocap::Link* _internal_add_links();
  public:
  const ::Mocap::Link& links(int index) const;
  ::Mocap::Link* add_links();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Link >&
      links() const;

  // repeated .Mocap.JointMeta joints = 5;
  int joints_size() const;
  private:
  int _internal_joints_size() const;
  public:
  void clear_joints();
  ::Mocap::JointMeta* mutable_joints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::JointMeta >*
      mutable_joints();
  private:
  const ::Mocap::JointMeta& _internal_joints(int index) const;
  ::Mocap::JointMeta* _internal_add_joints();
  public:
  const ::Mocap::JointMeta& joints(int index) const;
  ::Mocap::JointMeta* add_joints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::JointMeta >&
      joints() const;

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 structureId = 1;
  void clear_structureid();
  ::PROTOBUF_NAMESPACE_ID::uint32 structureid() const;
  void set_structureid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_structureid() const;
  void _internal_set_structureid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .Mocap.StructureType structureType = 2;
  void clear_structuretype();
  ::Mocap::StructureType structuretype() const;
  void set_structuretype(::Mocap::StructureType value);
  private:
  ::Mocap::StructureType _internal_structuretype() const;
  void _internal_set_structuretype(::Mocap::StructureType value);
  public:

  // @@protoc_insertion_point(class_scope:Mocap.Structure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Link > links_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::JointMeta > joints_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 structureid_;
  int structuretype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MocapExchange_2eproto;
};
// -------------------------------------------------------------------

class Joint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Mocap.Joint) */ {
 public:
  inline Joint() : Joint(nullptr) {}
  ~Joint() override;
  explicit constexpr Joint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Joint(const Joint& from);
  Joint(Joint&& from) noexcept
    : Joint() {
    *this = ::std::move(from);
  }

  inline Joint& operator=(const Joint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Joint& operator=(Joint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Joint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Joint* internal_default_instance() {
    return reinterpret_cast<const Joint*>(
               &_Joint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Joint& a, Joint& b) {
    a.Swap(&b);
  }
  inline void Swap(Joint* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Joint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Joint* New() const final {
    return new Joint();
  }

  Joint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Joint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Joint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Joint& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Joint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mocap.Joint";
  }
  protected:
  explicit Joint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransformFieldNumber = 2,
    kJointIdFieldNumber = 1,
  };
  // .Mocap.Transform transform = 2;
  bool has_transform() const;
  private:
  bool _internal_has_transform() const;
  public:
  void clear_transform();
  const ::Mocap::Transform& transform() const;
  PROTOBUF_MUST_USE_RESULT ::Mocap::Transform* release_transform();
  ::Mocap::Transform* mutable_transform();
  void set_allocated_transform(::Mocap::Transform* transform);
  private:
  const ::Mocap::Transform& _internal_transform() const;
  ::Mocap::Transform* _internal_mutable_transform();
  public:
  void unsafe_arena_set_allocated_transform(
      ::Mocap::Transform* transform);
  ::Mocap::Transform* unsafe_arena_release_transform();

  // uint32 jointId = 1;
  void clear_jointid();
  ::PROTOBUF_NAMESPACE_ID::uint32 jointid() const;
  void set_jointid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_jointid() const;
  void _internal_set_jointid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Mocap.Joint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Mocap::Transform* transform_;
  ::PROTOBUF_NAMESPACE_ID::uint32 jointid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MocapExchange_2eproto;
};
// -------------------------------------------------------------------

class Pose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Mocap.Pose) */ {
 public:
  inline Pose() : Pose(nullptr) {}
  ~Pose() override;
  explicit constexpr Pose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pose(const Pose& from);
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pose& operator=(Pose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pose& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }
  inline void Swap(Pose* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Pose* New() const final {
    return new Pose();
  }

  Pose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Pose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Pose& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mocap.Pose";
  }
  protected:
  explicit Pose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 3,
    kTimestampFieldNumber = 2,
    kSubjectIdFieldNumber = 1,
  };
  // repeated .Mocap.Joint joints = 3;
  int joints_size() const;
  private:
  int _internal_joints_size() const;
  public:
  void clear_joints();
  ::Mocap::Joint* mutable_joints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Joint >*
      mutable_joints();
  private:
  const ::Mocap::Joint& _internal_joints(int index) const;
  ::Mocap::Joint* _internal_add_joints();
  public:
  const ::Mocap::Joint& joints(int index) const;
  ::Mocap::Joint* add_joints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Joint >&
      joints() const;

  // uint64 timestamp = 2;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 subjectId = 1;
  void clear_subjectid();
  ::PROTOBUF_NAMESPACE_ID::uint32 subjectid() const;
  void set_subjectid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_subjectid() const;
  void _internal_set_subjectid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Mocap.Pose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Joint > joints_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint32 subjectid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MocapExchange_2eproto;
};
// -------------------------------------------------------------------

class EnvironmentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Mocap.EnvironmentRequest) */ {
 public:
  inline EnvironmentRequest() : EnvironmentRequest(nullptr) {}
  ~EnvironmentRequest() override;
  explicit constexpr EnvironmentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnvironmentRequest(const EnvironmentRequest& from);
  EnvironmentRequest(EnvironmentRequest&& from) noexcept
    : EnvironmentRequest() {
    *this = ::std::move(from);
  }

  inline EnvironmentRequest& operator=(const EnvironmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnvironmentRequest& operator=(EnvironmentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnvironmentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnvironmentRequest* internal_default_instance() {
    return reinterpret_cast<const EnvironmentRequest*>(
               &_EnvironmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EnvironmentRequest& a, EnvironmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EnvironmentRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnvironmentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnvironmentRequest* New() const final {
    return new EnvironmentRequest();
  }

  EnvironmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnvironmentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnvironmentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EnvironmentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnvironmentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mocap.EnvironmentRequest";
  }
  protected:
  explicit EnvironmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Mocap.EnvironmentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MocapExchange_2eproto;
};
// -------------------------------------------------------------------

class MocapStreamRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Mocap.MocapStreamRequest) */ {
 public:
  inline MocapStreamRequest() : MocapStreamRequest(nullptr) {}
  ~MocapStreamRequest() override;
  explicit constexpr MocapStreamRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MocapStreamRequest(const MocapStreamRequest& from);
  MocapStreamRequest(MocapStreamRequest&& from) noexcept
    : MocapStreamRequest() {
    *this = ::std::move(from);
  }

  inline MocapStreamRequest& operator=(const MocapStreamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MocapStreamRequest& operator=(MocapStreamRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MocapStreamRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MocapStreamRequest* internal_default_instance() {
    return reinterpret_cast<const MocapStreamRequest*>(
               &_MocapStreamRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MocapStreamRequest& a, MocapStreamRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MocapStreamRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MocapStreamRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MocapStreamRequest* New() const final {
    return new MocapStreamRequest();
  }

  MocapStreamRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MocapStreamRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MocapStreamRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MocapStreamRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MocapStreamRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mocap.MocapStreamRequest";
  }
  protected:
  explicit MocapStreamRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFpsFieldNumber = 1,
  };
  // float fps = 1;
  void clear_fps();
  float fps() const;
  void set_fps(float value);
  private:
  float _internal_fps() const;
  void _internal_set_fps(float value);
  public:

  // @@protoc_insertion_point(class_scope:Mocap.MocapStreamRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float fps_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MocapExchange_2eproto;
};
// -------------------------------------------------------------------

class MocapStreamResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Mocap.MocapStreamResponse) */ {
 public:
  inline MocapStreamResponse() : MocapStreamResponse(nullptr) {}
  ~MocapStreamResponse() override;
  explicit constexpr MocapStreamResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MocapStreamResponse(const MocapStreamResponse& from);
  MocapStreamResponse(MocapStreamResponse&& from) noexcept
    : MocapStreamResponse() {
    *this = ::std::move(from);
  }

  inline MocapStreamResponse& operator=(const MocapStreamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MocapStreamResponse& operator=(MocapStreamResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MocapStreamResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MocapStreamResponse* internal_default_instance() {
    return reinterpret_cast<const MocapStreamResponse*>(
               &_MocapStreamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MocapStreamResponse& a, MocapStreamResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MocapStreamResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MocapStreamResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MocapStreamResponse* New() const final {
    return new MocapStreamResponse();
  }

  MocapStreamResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MocapStreamResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MocapStreamResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MocapStreamResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MocapStreamResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mocap.MocapStreamResponse";
  }
  protected:
  explicit MocapStreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosesFieldNumber = 1,
    kServerTimeFieldNumber = 2,
  };
  // repeated .Mocap.Pose poses = 1;
  int poses_size() const;
  private:
  int _internal_poses_size() const;
  public:
  void clear_poses();
  ::Mocap::Pose* mutable_poses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Pose >*
      mutable_poses();
  private:
  const ::Mocap::Pose& _internal_poses(int index) const;
  ::Mocap::Pose* _internal_add_poses();
  public:
  const ::Mocap::Pose& poses(int index) const;
  ::Mocap::Pose* add_poses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Pose >&
      poses() const;

  // float serverTime = 2;
  void clear_servertime();
  float servertime() const;
  void set_servertime(float value);
  private:
  float _internal_servertime() const;
  void _internal_set_servertime(float value);
  public:

  // @@protoc_insertion_point(class_scope:Mocap.MocapStreamResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Pose > poses_;
  float servertime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MocapExchange_2eproto;
};
// -------------------------------------------------------------------

class StructureRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Mocap.StructureRequest) */ {
 public:
  inline StructureRequest() : StructureRequest(nullptr) {}
  ~StructureRequest() override;
  explicit constexpr StructureRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StructureRequest(const StructureRequest& from);
  StructureRequest(StructureRequest&& from) noexcept
    : StructureRequest() {
    *this = ::std::move(from);
  }

  inline StructureRequest& operator=(const StructureRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StructureRequest& operator=(StructureRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StructureRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StructureRequest* internal_default_instance() {
    return reinterpret_cast<const StructureRequest*>(
               &_StructureRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StructureRequest& a, StructureRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StructureRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StructureRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StructureRequest* New() const final {
    return new StructureRequest();
  }

  StructureRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StructureRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StructureRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StructureRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StructureRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mocap.StructureRequest";
  }
  protected:
  explicit StructureRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // repeated uint32 id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;
  public:
  void clear_id();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_id() const;
  void _internal_add_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_id();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 id(int index) const;
  void set_id(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_id();

  // @@protoc_insertion_point(class_scope:Mocap.StructureRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > id_;
  mutable std::atomic<int> _id_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MocapExchange_2eproto;
};
// -------------------------------------------------------------------

class StructureResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Mocap.StructureResponse) */ {
 public:
  inline StructureResponse() : StructureResponse(nullptr) {}
  ~StructureResponse() override;
  explicit constexpr StructureResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StructureResponse(const StructureResponse& from);
  StructureResponse(StructureResponse&& from) noexcept
    : StructureResponse() {
    *this = ::std::move(from);
  }

  inline StructureResponse& operator=(const StructureResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StructureResponse& operator=(StructureResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StructureResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StructureResponse* internal_default_instance() {
    return reinterpret_cast<const StructureResponse*>(
               &_StructureResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(StructureResponse& a, StructureResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StructureResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StructureResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StructureResponse* New() const final {
    return new StructureResponse();
  }

  StructureResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StructureResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StructureResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StructureResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StructureResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mocap.StructureResponse";
  }
  protected:
  explicit StructureResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStructuresFieldNumber = 1,
  };
  // repeated .Mocap.Structure structures = 1;
  int structures_size() const;
  private:
  int _internal_structures_size() const;
  public:
  void clear_structures();
  ::Mocap::Structure* mutable_structures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Structure >*
      mutable_structures();
  private:
  const ::Mocap::Structure& _internal_structures(int index) const;
  ::Mocap::Structure* _internal_add_structures();
  public:
  const ::Mocap::Structure& structures(int index) const;
  ::Mocap::Structure* add_structures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Structure >&
      structures() const;

  // @@protoc_insertion_point(class_scope:Mocap.StructureResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Structure > structures_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MocapExchange_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Environment

// float gravity = 1;
inline void Environment::clear_gravity() {
  gravity_ = 0;
}
inline float Environment::_internal_gravity() const {
  return gravity_;
}
inline float Environment::gravity() const {
  // @@protoc_insertion_point(field_get:Mocap.Environment.gravity)
  return _internal_gravity();
}
inline void Environment::_internal_set_gravity(float value) {
  
  gravity_ = value;
}
inline void Environment::set_gravity(float value) {
  _internal_set_gravity(value);
  // @@protoc_insertion_point(field_set:Mocap.Environment.gravity)
}

// .Mocap.Environment.DistanceUnits distUnits = 2;
inline void Environment::clear_distunits() {
  distunits_ = 0;
}
inline ::Mocap::Environment_DistanceUnits Environment::_internal_distunits() const {
  return static_cast< ::Mocap::Environment_DistanceUnits >(distunits_);
}
inline ::Mocap::Environment_DistanceUnits Environment::distunits() const {
  // @@protoc_insertion_point(field_get:Mocap.Environment.distUnits)
  return _internal_distunits();
}
inline void Environment::_internal_set_distunits(::Mocap::Environment_DistanceUnits value) {
  
  distunits_ = value;
}
inline void Environment::set_distunits(::Mocap::Environment_DistanceUnits value) {
  _internal_set_distunits(value);
  // @@protoc_insertion_point(field_set:Mocap.Environment.distUnits)
}

// .Mocap.Environment.TimeUnits timeUnits = 3;
inline void Environment::clear_timeunits() {
  timeunits_ = 0;
}
inline ::Mocap::Environment_TimeUnits Environment::_internal_timeunits() const {
  return static_cast< ::Mocap::Environment_TimeUnits >(timeunits_);
}
inline ::Mocap::Environment_TimeUnits Environment::timeunits() const {
  // @@protoc_insertion_point(field_get:Mocap.Environment.timeUnits)
  return _internal_timeunits();
}
inline void Environment::_internal_set_timeunits(::Mocap::Environment_TimeUnits value) {
  
  timeunits_ = value;
}
inline void Environment::set_timeunits(::Mocap::Environment_TimeUnits value) {
  _internal_set_timeunits(value);
  // @@protoc_insertion_point(field_set:Mocap.Environment.timeUnits)
}

// .Mocap.Environment.DirectionType directionType = 4;
inline void Environment::clear_directiontype() {
  directiontype_ = 0;
}
inline ::Mocap::Environment_DirectionType Environment::_internal_directiontype() const {
  return static_cast< ::Mocap::Environment_DirectionType >(directiontype_);
}
inline ::Mocap::Environment_DirectionType Environment::directiontype() const {
  // @@protoc_insertion_point(field_get:Mocap.Environment.directionType)
  return _internal_directiontype();
}
inline void Environment::_internal_set_directiontype(::Mocap::Environment_DirectionType value) {
  
  directiontype_ = value;
}
inline void Environment::set_directiontype(::Mocap::Environment_DirectionType value) {
  _internal_set_directiontype(value);
  // @@protoc_insertion_point(field_set:Mocap.Environment.directionType)
}

// -------------------------------------------------------------------

// Translation

// float x = 1;
inline void Translation::clear_x() {
  x_ = 0;
}
inline float Translation::_internal_x() const {
  return x_;
}
inline float Translation::x() const {
  // @@protoc_insertion_point(field_get:Mocap.Translation.x)
  return _internal_x();
}
inline void Translation::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Translation::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Mocap.Translation.x)
}

// float y = 2;
inline void Translation::clear_y() {
  y_ = 0;
}
inline float Translation::_internal_y() const {
  return y_;
}
inline float Translation::y() const {
  // @@protoc_insertion_point(field_get:Mocap.Translation.y)
  return _internal_y();
}
inline void Translation::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Translation::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Mocap.Translation.y)
}

// float z = 3;
inline void Translation::clear_z() {
  z_ = 0;
}
inline float Translation::_internal_z() const {
  return z_;
}
inline float Translation::z() const {
  // @@protoc_insertion_point(field_get:Mocap.Translation.z)
  return _internal_z();
}
inline void Translation::_internal_set_z(float value) {
  
  z_ = value;
}
inline void Translation::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Mocap.Translation.z)
}

// -------------------------------------------------------------------

// Orientation

// .Mocap.Orientation.RotationType type = 1;
inline void Orientation::clear_type() {
  type_ = 0;
}
inline ::Mocap::Orientation_RotationType Orientation::_internal_type() const {
  return static_cast< ::Mocap::Orientation_RotationType >(type_);
}
inline ::Mocap::Orientation_RotationType Orientation::type() const {
  // @@protoc_insertion_point(field_get:Mocap.Orientation.type)
  return _internal_type();
}
inline void Orientation::_internal_set_type(::Mocap::Orientation_RotationType value) {
  
  type_ = value;
}
inline void Orientation::set_type(::Mocap::Orientation_RotationType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Mocap.Orientation.type)
}

// repeated float values = 2;
inline int Orientation::_internal_values_size() const {
  return values_.size();
}
inline int Orientation::values_size() const {
  return _internal_values_size();
}
inline void Orientation::clear_values() {
  values_.Clear();
}
inline float Orientation::_internal_values(int index) const {
  return values_.Get(index);
}
inline float Orientation::values(int index) const {
  // @@protoc_insertion_point(field_get:Mocap.Orientation.values)
  return _internal_values(index);
}
inline void Orientation::set_values(int index, float value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:Mocap.Orientation.values)
}
inline void Orientation::_internal_add_values(float value) {
  values_.Add(value);
}
inline void Orientation::add_values(float value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:Mocap.Orientation.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Orientation::_internal_values() const {
  return values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Orientation::values() const {
  // @@protoc_insertion_point(field_list:Mocap.Orientation.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Orientation::_internal_mutable_values() {
  return &values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Orientation::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:Mocap.Orientation.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Transform

// .Mocap.Translation translation = 1;
inline bool Transform::_internal_has_translation() const {
  return this != internal_default_instance() && translation_ != nullptr;
}
inline bool Transform::has_translation() const {
  return _internal_has_translation();
}
inline void Transform::clear_translation() {
  if (GetArenaForAllocation() == nullptr && translation_ != nullptr) {
    delete translation_;
  }
  translation_ = nullptr;
}
inline const ::Mocap::Translation& Transform::_internal_translation() const {
  const ::Mocap::Translation* p = translation_;
  return p != nullptr ? *p : reinterpret_cast<const ::Mocap::Translation&>(
      ::Mocap::_Translation_default_instance_);
}
inline const ::Mocap::Translation& Transform::translation() const {
  // @@protoc_insertion_point(field_get:Mocap.Transform.translation)
  return _internal_translation();
}
inline void Transform::unsafe_arena_set_allocated_translation(
    ::Mocap::Translation* translation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(translation_);
  }
  translation_ = translation;
  if (translation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Mocap.Transform.translation)
}
inline ::Mocap::Translation* Transform::release_translation() {
  
  ::Mocap::Translation* temp = translation_;
  translation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Mocap::Translation* Transform::unsafe_arena_release_translation() {
  // @@protoc_insertion_point(field_release:Mocap.Transform.translation)
  
  ::Mocap::Translation* temp = translation_;
  translation_ = nullptr;
  return temp;
}
inline ::Mocap::Translation* Transform::_internal_mutable_translation() {
  
  if (translation_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mocap::Translation>(GetArenaForAllocation());
    translation_ = p;
  }
  return translation_;
}
inline ::Mocap::Translation* Transform::mutable_translation() {
  ::Mocap::Translation* _msg = _internal_mutable_translation();
  // @@protoc_insertion_point(field_mutable:Mocap.Transform.translation)
  return _msg;
}
inline void Transform::set_allocated_translation(::Mocap::Translation* translation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete translation_;
  }
  if (translation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Mocap::Translation>::GetOwningArena(translation);
    if (message_arena != submessage_arena) {
      translation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, translation, submessage_arena);
    }
    
  } else {
    
  }
  translation_ = translation;
  // @@protoc_insertion_point(field_set_allocated:Mocap.Transform.translation)
}

// .Mocap.Orientation orientation = 2;
inline bool Transform::_internal_has_orientation() const {
  return this != internal_default_instance() && orientation_ != nullptr;
}
inline bool Transform::has_orientation() const {
  return _internal_has_orientation();
}
inline void Transform::clear_orientation() {
  if (GetArenaForAllocation() == nullptr && orientation_ != nullptr) {
    delete orientation_;
  }
  orientation_ = nullptr;
}
inline const ::Mocap::Orientation& Transform::_internal_orientation() const {
  const ::Mocap::Orientation* p = orientation_;
  return p != nullptr ? *p : reinterpret_cast<const ::Mocap::Orientation&>(
      ::Mocap::_Orientation_default_instance_);
}
inline const ::Mocap::Orientation& Transform::orientation() const {
  // @@protoc_insertion_point(field_get:Mocap.Transform.orientation)
  return _internal_orientation();
}
inline void Transform::unsafe_arena_set_allocated_orientation(
    ::Mocap::Orientation* orientation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(orientation_);
  }
  orientation_ = orientation;
  if (orientation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Mocap.Transform.orientation)
}
inline ::Mocap::Orientation* Transform::release_orientation() {
  
  ::Mocap::Orientation* temp = orientation_;
  orientation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Mocap::Orientation* Transform::unsafe_arena_release_orientation() {
  // @@protoc_insertion_point(field_release:Mocap.Transform.orientation)
  
  ::Mocap::Orientation* temp = orientation_;
  orientation_ = nullptr;
  return temp;
}
inline ::Mocap::Orientation* Transform::_internal_mutable_orientation() {
  
  if (orientation_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mocap::Orientation>(GetArenaForAllocation());
    orientation_ = p;
  }
  return orientation_;
}
inline ::Mocap::Orientation* Transform::mutable_orientation() {
  ::Mocap::Orientation* _msg = _internal_mutable_orientation();
  // @@protoc_insertion_point(field_mutable:Mocap.Transform.orientation)
  return _msg;
}
inline void Transform::set_allocated_orientation(::Mocap::Orientation* orientation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete orientation_;
  }
  if (orientation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Mocap::Orientation>::GetOwningArena(orientation);
    if (message_arena != submessage_arena) {
      orientation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    
  } else {
    
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:Mocap.Transform.orientation)
}

// -------------------------------------------------------------------

// Link

// string name = 1;
inline void Link::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Link::name() const {
  // @@protoc_insertion_point(field_get:Mocap.Link.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Link::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Mocap.Link.name)
}
inline std::string* Link::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Mocap.Link.name)
  return _s;
}
inline const std::string& Link::_internal_name() const {
  return name_.Get();
}
inline void Link::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Link::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Link::release_name() {
  // @@protoc_insertion_point(field_release:Mocap.Link.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Link::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Mocap.Link.name)
}

// uint32 linkId = 2;
inline void Link::clear_linkid() {
  linkid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Link::_internal_linkid() const {
  return linkid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Link::linkid() const {
  // @@protoc_insertion_point(field_get:Mocap.Link.linkId)
  return _internal_linkid();
}
inline void Link::_internal_set_linkid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  linkid_ = value;
}
inline void Link::set_linkid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_linkid(value);
  // @@protoc_insertion_point(field_set:Mocap.Link.linkId)
}

// uint32 parentLinkId = 3;
inline void Link::clear_parentlinkid() {
  parentlinkid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Link::_internal_parentlinkid() const {
  return parentlinkid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Link::parentlinkid() const {
  // @@protoc_insertion_point(field_get:Mocap.Link.parentLinkId)
  return _internal_parentlinkid();
}
inline void Link::_internal_set_parentlinkid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  parentlinkid_ = value;
}
inline void Link::set_parentlinkid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_parentlinkid(value);
  // @@protoc_insertion_point(field_set:Mocap.Link.parentLinkId)
}

// .Mocap.Transform offset = 4;
inline bool Link::_internal_has_offset() const {
  return this != internal_default_instance() && offset_ != nullptr;
}
inline bool Link::has_offset() const {
  return _internal_has_offset();
}
inline void Link::clear_offset() {
  if (GetArenaForAllocation() == nullptr && offset_ != nullptr) {
    delete offset_;
  }
  offset_ = nullptr;
}
inline const ::Mocap::Transform& Link::_internal_offset() const {
  const ::Mocap::Transform* p = offset_;
  return p != nullptr ? *p : reinterpret_cast<const ::Mocap::Transform&>(
      ::Mocap::_Transform_default_instance_);
}
inline const ::Mocap::Transform& Link::offset() const {
  // @@protoc_insertion_point(field_get:Mocap.Link.offset)
  return _internal_offset();
}
inline void Link::unsafe_arena_set_allocated_offset(
    ::Mocap::Transform* offset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(offset_);
  }
  offset_ = offset;
  if (offset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Mocap.Link.offset)
}
inline ::Mocap::Transform* Link::release_offset() {
  
  ::Mocap::Transform* temp = offset_;
  offset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Mocap::Transform* Link::unsafe_arena_release_offset() {
  // @@protoc_insertion_point(field_release:Mocap.Link.offset)
  
  ::Mocap::Transform* temp = offset_;
  offset_ = nullptr;
  return temp;
}
inline ::Mocap::Transform* Link::_internal_mutable_offset() {
  
  if (offset_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mocap::Transform>(GetArenaForAllocation());
    offset_ = p;
  }
  return offset_;
}
inline ::Mocap::Transform* Link::mutable_offset() {
  ::Mocap::Transform* _msg = _internal_mutable_offset();
  // @@protoc_insertion_point(field_mutable:Mocap.Link.offset)
  return _msg;
}
inline void Link::set_allocated_offset(::Mocap::Transform* offset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete offset_;
  }
  if (offset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Mocap::Transform>::GetOwningArena(offset);
    if (message_arena != submessage_arena) {
      offset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offset, submessage_arena);
    }
    
  } else {
    
  }
  offset_ = offset;
  // @@protoc_insertion_point(field_set_allocated:Mocap.Link.offset)
}

// float mass = 5;
inline void Link::clear_mass() {
  mass_ = 0;
}
inline float Link::_internal_mass() const {
  return mass_;
}
inline float Link::mass() const {
  // @@protoc_insertion_point(field_get:Mocap.Link.mass)
  return _internal_mass();
}
inline void Link::_internal_set_mass(float value) {
  
  mass_ = value;
}
inline void Link::set_mass(float value) {
  _internal_set_mass(value);
  // @@protoc_insertion_point(field_set:Mocap.Link.mass)
}

// repeated float size = 6;
inline int Link::_internal_size_size() const {
  return size_.size();
}
inline int Link::size_size() const {
  return _internal_size_size();
}
inline void Link::clear_size() {
  size_.Clear();
}
inline float Link::_internal_size(int index) const {
  return size_.Get(index);
}
inline float Link::size(int index) const {
  // @@protoc_insertion_point(field_get:Mocap.Link.size)
  return _internal_size(index);
}
inline void Link::set_size(int index, float value) {
  size_.Set(index, value);
  // @@protoc_insertion_point(field_set:Mocap.Link.size)
}
inline void Link::_internal_add_size(float value) {
  size_.Add(value);
}
inline void Link::add_size(float value) {
  _internal_add_size(value);
  // @@protoc_insertion_point(field_add:Mocap.Link.size)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Link::_internal_size() const {
  return size_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Link::size() const {
  // @@protoc_insertion_point(field_list:Mocap.Link.size)
  return _internal_size();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Link::_internal_mutable_size() {
  return &size_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Link::mutable_size() {
  // @@protoc_insertion_point(field_mutable_list:Mocap.Link.size)
  return _internal_mutable_size();
}

// repeated float inertialMatrix = 7;
inline int Link::_internal_inertialmatrix_size() const {
  return inertialmatrix_.size();
}
inline int Link::inertialmatrix_size() const {
  return _internal_inertialmatrix_size();
}
inline void Link::clear_inertialmatrix() {
  inertialmatrix_.Clear();
}
inline float Link::_internal_inertialmatrix(int index) const {
  return inertialmatrix_.Get(index);
}
inline float Link::inertialmatrix(int index) const {
  // @@protoc_insertion_point(field_get:Mocap.Link.inertialMatrix)
  return _internal_inertialmatrix(index);
}
inline void Link::set_inertialmatrix(int index, float value) {
  inertialmatrix_.Set(index, value);
  // @@protoc_insertion_point(field_set:Mocap.Link.inertialMatrix)
}
inline void Link::_internal_add_inertialmatrix(float value) {
  inertialmatrix_.Add(value);
}
inline void Link::add_inertialmatrix(float value) {
  _internal_add_inertialmatrix(value);
  // @@protoc_insertion_point(field_add:Mocap.Link.inertialMatrix)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Link::_internal_inertialmatrix() const {
  return inertialmatrix_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Link::inertialmatrix() const {
  // @@protoc_insertion_point(field_list:Mocap.Link.inertialMatrix)
  return _internal_inertialmatrix();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Link::_internal_mutable_inertialmatrix() {
  return &inertialmatrix_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Link::mutable_inertialmatrix() {
  // @@protoc_insertion_point(field_mutable_list:Mocap.Link.inertialMatrix)
  return _internal_mutable_inertialmatrix();
}

// -------------------------------------------------------------------

// JointMeta

// uint32 jointId = 1;
inline void JointMeta::clear_jointid() {
  jointid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JointMeta::_internal_jointid() const {
  return jointid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JointMeta::jointid() const {
  // @@protoc_insertion_point(field_get:Mocap.JointMeta.jointId)
  return _internal_jointid();
}
inline void JointMeta::_internal_set_jointid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  jointid_ = value;
}
inline void JointMeta::set_jointid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_jointid(value);
  // @@protoc_insertion_point(field_set:Mocap.JointMeta.jointId)
}

// uint32 linkId = 2;
inline void JointMeta::clear_linkid() {
  linkid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JointMeta::_internal_linkid() const {
  return linkid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 JointMeta::linkid() const {
  // @@protoc_insertion_point(field_get:Mocap.JointMeta.linkId)
  return _internal_linkid();
}
inline void JointMeta::_internal_set_linkid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  linkid_ = value;
}
inline void JointMeta::set_linkid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_linkid(value);
  // @@protoc_insertion_point(field_set:Mocap.JointMeta.linkId)
}

// string name = 3;
inline void JointMeta::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& JointMeta::name() const {
  // @@protoc_insertion_point(field_get:Mocap.JointMeta.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JointMeta::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Mocap.JointMeta.name)
}
inline std::string* JointMeta::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Mocap.JointMeta.name)
  return _s;
}
inline const std::string& JointMeta::_internal_name() const {
  return name_.Get();
}
inline void JointMeta::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JointMeta::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JointMeta::release_name() {
  // @@protoc_insertion_point(field_release:Mocap.JointMeta.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void JointMeta::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Mocap.JointMeta.name)
}

// -------------------------------------------------------------------

// Structure

// uint32 structureId = 1;
inline void Structure::clear_structureid() {
  structureid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Structure::_internal_structureid() const {
  return structureid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Structure::structureid() const {
  // @@protoc_insertion_point(field_get:Mocap.Structure.structureId)
  return _internal_structureid();
}
inline void Structure::_internal_set_structureid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  structureid_ = value;
}
inline void Structure::set_structureid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_structureid(value);
  // @@protoc_insertion_point(field_set:Mocap.Structure.structureId)
}

// .Mocap.StructureType structureType = 2;
inline void Structure::clear_structuretype() {
  structuretype_ = 0;
}
inline ::Mocap::StructureType Structure::_internal_structuretype() const {
  return static_cast< ::Mocap::StructureType >(structuretype_);
}
inline ::Mocap::StructureType Structure::structuretype() const {
  // @@protoc_insertion_point(field_get:Mocap.Structure.structureType)
  return _internal_structuretype();
}
inline void Structure::_internal_set_structuretype(::Mocap::StructureType value) {
  
  structuretype_ = value;
}
inline void Structure::set_structuretype(::Mocap::StructureType value) {
  _internal_set_structuretype(value);
  // @@protoc_insertion_point(field_set:Mocap.Structure.structureType)
}

// string name = 3;
inline void Structure::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Structure::name() const {
  // @@protoc_insertion_point(field_get:Mocap.Structure.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Structure::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Mocap.Structure.name)
}
inline std::string* Structure::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Mocap.Structure.name)
  return _s;
}
inline const std::string& Structure::_internal_name() const {
  return name_.Get();
}
inline void Structure::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Structure::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Structure::release_name() {
  // @@protoc_insertion_point(field_release:Mocap.Structure.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Structure::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Mocap.Structure.name)
}

// repeated .Mocap.Link links = 4;
inline int Structure::_internal_links_size() const {
  return links_.size();
}
inline int Structure::links_size() const {
  return _internal_links_size();
}
inline void Structure::clear_links() {
  links_.Clear();
}
inline ::Mocap::Link* Structure::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:Mocap.Structure.links)
  return links_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Link >*
Structure::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:Mocap.Structure.links)
  return &links_;
}
inline const ::Mocap::Link& Structure::_internal_links(int index) const {
  return links_.Get(index);
}
inline const ::Mocap::Link& Structure::links(int index) const {
  // @@protoc_insertion_point(field_get:Mocap.Structure.links)
  return _internal_links(index);
}
inline ::Mocap::Link* Structure::_internal_add_links() {
  return links_.Add();
}
inline ::Mocap::Link* Structure::add_links() {
  ::Mocap::Link* _add = _internal_add_links();
  // @@protoc_insertion_point(field_add:Mocap.Structure.links)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Link >&
Structure::links() const {
  // @@protoc_insertion_point(field_list:Mocap.Structure.links)
  return links_;
}

// repeated .Mocap.JointMeta joints = 5;
inline int Structure::_internal_joints_size() const {
  return joints_.size();
}
inline int Structure::joints_size() const {
  return _internal_joints_size();
}
inline void Structure::clear_joints() {
  joints_.Clear();
}
inline ::Mocap::JointMeta* Structure::mutable_joints(int index) {
  // @@protoc_insertion_point(field_mutable:Mocap.Structure.joints)
  return joints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::JointMeta >*
Structure::mutable_joints() {
  // @@protoc_insertion_point(field_mutable_list:Mocap.Structure.joints)
  return &joints_;
}
inline const ::Mocap::JointMeta& Structure::_internal_joints(int index) const {
  return joints_.Get(index);
}
inline const ::Mocap::JointMeta& Structure::joints(int index) const {
  // @@protoc_insertion_point(field_get:Mocap.Structure.joints)
  return _internal_joints(index);
}
inline ::Mocap::JointMeta* Structure::_internal_add_joints() {
  return joints_.Add();
}
inline ::Mocap::JointMeta* Structure::add_joints() {
  ::Mocap::JointMeta* _add = _internal_add_joints();
  // @@protoc_insertion_point(field_add:Mocap.Structure.joints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::JointMeta >&
Structure::joints() const {
  // @@protoc_insertion_point(field_list:Mocap.Structure.joints)
  return joints_;
}

// -------------------------------------------------------------------

// Joint

// uint32 jointId = 1;
inline void Joint::clear_jointid() {
  jointid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Joint::_internal_jointid() const {
  return jointid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Joint::jointid() const {
  // @@protoc_insertion_point(field_get:Mocap.Joint.jointId)
  return _internal_jointid();
}
inline void Joint::_internal_set_jointid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  jointid_ = value;
}
inline void Joint::set_jointid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_jointid(value);
  // @@protoc_insertion_point(field_set:Mocap.Joint.jointId)
}

// .Mocap.Transform transform = 2;
inline bool Joint::_internal_has_transform() const {
  return this != internal_default_instance() && transform_ != nullptr;
}
inline bool Joint::has_transform() const {
  return _internal_has_transform();
}
inline void Joint::clear_transform() {
  if (GetArenaForAllocation() == nullptr && transform_ != nullptr) {
    delete transform_;
  }
  transform_ = nullptr;
}
inline const ::Mocap::Transform& Joint::_internal_transform() const {
  const ::Mocap::Transform* p = transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::Mocap::Transform&>(
      ::Mocap::_Transform_default_instance_);
}
inline const ::Mocap::Transform& Joint::transform() const {
  // @@protoc_insertion_point(field_get:Mocap.Joint.transform)
  return _internal_transform();
}
inline void Joint::unsafe_arena_set_allocated_transform(
    ::Mocap::Transform* transform) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transform_);
  }
  transform_ = transform;
  if (transform) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Mocap.Joint.transform)
}
inline ::Mocap::Transform* Joint::release_transform() {
  
  ::Mocap::Transform* temp = transform_;
  transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Mocap::Transform* Joint::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_release:Mocap.Joint.transform)
  
  ::Mocap::Transform* temp = transform_;
  transform_ = nullptr;
  return temp;
}
inline ::Mocap::Transform* Joint::_internal_mutable_transform() {
  
  if (transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mocap::Transform>(GetArenaForAllocation());
    transform_ = p;
  }
  return transform_;
}
inline ::Mocap::Transform* Joint::mutable_transform() {
  ::Mocap::Transform* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:Mocap.Joint.transform)
  return _msg;
}
inline void Joint::set_allocated_transform(::Mocap::Transform* transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete transform_;
  }
  if (transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Mocap::Transform>::GetOwningArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    
  } else {
    
  }
  transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:Mocap.Joint.transform)
}

// -------------------------------------------------------------------

// Pose

// uint32 subjectId = 1;
inline void Pose::clear_subjectid() {
  subjectid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Pose::_internal_subjectid() const {
  return subjectid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Pose::subjectid() const {
  // @@protoc_insertion_point(field_get:Mocap.Pose.subjectId)
  return _internal_subjectid();
}
inline void Pose::_internal_set_subjectid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  subjectid_ = value;
}
inline void Pose::set_subjectid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_subjectid(value);
  // @@protoc_insertion_point(field_set:Mocap.Pose.subjectId)
}

// uint64 timestamp = 2;
inline void Pose::clear_timestamp() {
  timestamp_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Pose::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Pose::timestamp() const {
  // @@protoc_insertion_point(field_get:Mocap.Pose.timestamp)
  return _internal_timestamp();
}
inline void Pose::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  timestamp_ = value;
}
inline void Pose::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:Mocap.Pose.timestamp)
}

// repeated .Mocap.Joint joints = 3;
inline int Pose::_internal_joints_size() const {
  return joints_.size();
}
inline int Pose::joints_size() const {
  return _internal_joints_size();
}
inline void Pose::clear_joints() {
  joints_.Clear();
}
inline ::Mocap::Joint* Pose::mutable_joints(int index) {
  // @@protoc_insertion_point(field_mutable:Mocap.Pose.joints)
  return joints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Joint >*
Pose::mutable_joints() {
  // @@protoc_insertion_point(field_mutable_list:Mocap.Pose.joints)
  return &joints_;
}
inline const ::Mocap::Joint& Pose::_internal_joints(int index) const {
  return joints_.Get(index);
}
inline const ::Mocap::Joint& Pose::joints(int index) const {
  // @@protoc_insertion_point(field_get:Mocap.Pose.joints)
  return _internal_joints(index);
}
inline ::Mocap::Joint* Pose::_internal_add_joints() {
  return joints_.Add();
}
inline ::Mocap::Joint* Pose::add_joints() {
  ::Mocap::Joint* _add = _internal_add_joints();
  // @@protoc_insertion_point(field_add:Mocap.Pose.joints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Joint >&
Pose::joints() const {
  // @@protoc_insertion_point(field_list:Mocap.Pose.joints)
  return joints_;
}

// -------------------------------------------------------------------

// EnvironmentRequest

// -------------------------------------------------------------------

// MocapStreamRequest

// float fps = 1;
inline void MocapStreamRequest::clear_fps() {
  fps_ = 0;
}
inline float MocapStreamRequest::_internal_fps() const {
  return fps_;
}
inline float MocapStreamRequest::fps() const {
  // @@protoc_insertion_point(field_get:Mocap.MocapStreamRequest.fps)
  return _internal_fps();
}
inline void MocapStreamRequest::_internal_set_fps(float value) {
  
  fps_ = value;
}
inline void MocapStreamRequest::set_fps(float value) {
  _internal_set_fps(value);
  // @@protoc_insertion_point(field_set:Mocap.MocapStreamRequest.fps)
}

// -------------------------------------------------------------------

// MocapStreamResponse

// repeated .Mocap.Pose poses = 1;
inline int MocapStreamResponse::_internal_poses_size() const {
  return poses_.size();
}
inline int MocapStreamResponse::poses_size() const {
  return _internal_poses_size();
}
inline void MocapStreamResponse::clear_poses() {
  poses_.Clear();
}
inline ::Mocap::Pose* MocapStreamResponse::mutable_poses(int index) {
  // @@protoc_insertion_point(field_mutable:Mocap.MocapStreamResponse.poses)
  return poses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Pose >*
MocapStreamResponse::mutable_poses() {
  // @@protoc_insertion_point(field_mutable_list:Mocap.MocapStreamResponse.poses)
  return &poses_;
}
inline const ::Mocap::Pose& MocapStreamResponse::_internal_poses(int index) const {
  return poses_.Get(index);
}
inline const ::Mocap::Pose& MocapStreamResponse::poses(int index) const {
  // @@protoc_insertion_point(field_get:Mocap.MocapStreamResponse.poses)
  return _internal_poses(index);
}
inline ::Mocap::Pose* MocapStreamResponse::_internal_add_poses() {
  return poses_.Add();
}
inline ::Mocap::Pose* MocapStreamResponse::add_poses() {
  ::Mocap::Pose* _add = _internal_add_poses();
  // @@protoc_insertion_point(field_add:Mocap.MocapStreamResponse.poses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Pose >&
MocapStreamResponse::poses() const {
  // @@protoc_insertion_point(field_list:Mocap.MocapStreamResponse.poses)
  return poses_;
}

// float serverTime = 2;
inline void MocapStreamResponse::clear_servertime() {
  servertime_ = 0;
}
inline float MocapStreamResponse::_internal_servertime() const {
  return servertime_;
}
inline float MocapStreamResponse::servertime() const {
  // @@protoc_insertion_point(field_get:Mocap.MocapStreamResponse.serverTime)
  return _internal_servertime();
}
inline void MocapStreamResponse::_internal_set_servertime(float value) {
  
  servertime_ = value;
}
inline void MocapStreamResponse::set_servertime(float value) {
  _internal_set_servertime(value);
  // @@protoc_insertion_point(field_set:Mocap.MocapStreamResponse.serverTime)
}

// -------------------------------------------------------------------

// StructureRequest

// repeated uint32 id = 1;
inline int StructureRequest::_internal_id_size() const {
  return id_.size();
}
inline int StructureRequest::id_size() const {
  return _internal_id_size();
}
inline void StructureRequest::clear_id() {
  id_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StructureRequest::_internal_id(int index) const {
  return id_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StructureRequest::id(int index) const {
  // @@protoc_insertion_point(field_get:Mocap.StructureRequest.id)
  return _internal_id(index);
}
inline void StructureRequest::set_id(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  id_.Set(index, value);
  // @@protoc_insertion_point(field_set:Mocap.StructureRequest.id)
}
inline void StructureRequest::_internal_add_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  id_.Add(value);
}
inline void StructureRequest::add_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_id(value);
  // @@protoc_insertion_point(field_add:Mocap.StructureRequest.id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
StructureRequest::_internal_id() const {
  return id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
StructureRequest::id() const {
  // @@protoc_insertion_point(field_list:Mocap.StructureRequest.id)
  return _internal_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
StructureRequest::_internal_mutable_id() {
  return &id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
StructureRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable_list:Mocap.StructureRequest.id)
  return _internal_mutable_id();
}

// -------------------------------------------------------------------

// StructureResponse

// repeated .Mocap.Structure structures = 1;
inline int StructureResponse::_internal_structures_size() const {
  return structures_.size();
}
inline int StructureResponse::structures_size() const {
  return _internal_structures_size();
}
inline void StructureResponse::clear_structures() {
  structures_.Clear();
}
inline ::Mocap::Structure* StructureResponse::mutable_structures(int index) {
  // @@protoc_insertion_point(field_mutable:Mocap.StructureResponse.structures)
  return structures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Structure >*
StructureResponse::mutable_structures() {
  // @@protoc_insertion_point(field_mutable_list:Mocap.StructureResponse.structures)
  return &structures_;
}
inline const ::Mocap::Structure& StructureResponse::_internal_structures(int index) const {
  return structures_.Get(index);
}
inline const ::Mocap::Structure& StructureResponse::structures(int index) const {
  // @@protoc_insertion_point(field_get:Mocap.StructureResponse.structures)
  return _internal_structures(index);
}
inline ::Mocap::Structure* StructureResponse::_internal_add_structures() {
  return structures_.Add();
}
inline ::Mocap::Structure* StructureResponse::add_structures() {
  ::Mocap::Structure* _add = _internal_add_structures();
  // @@protoc_insertion_point(field_add:Mocap.StructureResponse.structures)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mocap::Structure >&
StructureResponse::structures() const {
  // @@protoc_insertion_point(field_list:Mocap.StructureResponse.structures)
  return structures_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Mocap

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Mocap::Environment_DirectionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mocap::Environment_DirectionType>() {
  return ::Mocap::Environment_DirectionType_descriptor();
}
template <> struct is_proto_enum< ::Mocap::Environment_DistanceUnits> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mocap::Environment_DistanceUnits>() {
  return ::Mocap::Environment_DistanceUnits_descriptor();
}
template <> struct is_proto_enum< ::Mocap::Environment_TimeUnits> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mocap::Environment_TimeUnits>() {
  return ::Mocap::Environment_TimeUnits_descriptor();
}
template <> struct is_proto_enum< ::Mocap::Orientation_RotationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mocap::Orientation_RotationType>() {
  return ::Mocap::Orientation_RotationType_descriptor();
}
template <> struct is_proto_enum< ::Mocap::StructureType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mocap::StructureType>() {
  return ::Mocap::StructureType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
THIRD_PARTY_INCLUDES_START
#include <google/protobuf/port_undef.inc>
THIRD_PARTY_INCLUDES_END
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_MocapExchange_2eproto
